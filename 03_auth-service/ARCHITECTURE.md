# Архитектурная документация Auth Service

## ADR-001: Выбор Clean Architecture

**Дата**: Январь 2024  
**Статус**: Принято  
**Контекст**: Необходимость создания масштабируемого, поддерживаемого микросервиса аутентификации с четким разделением ответственности.

**Решение**: Применение Clean Architecture (Ports & Adapters) с 4 слоями:
1. **Domain** - чистая бизнес-логика
2. **Application** - use cases и координация
3. **Infrastructure** - реализация портов
4. **Presentation** - контроллеры и API

**Последствия**:
- ✅ Высокая тестируемость
- ✅ Независимость от фреймворков
- ✅ Легкая замена компонентов
- ⚠️ Больше boilerplate кода
- ⚠️ Сложнее для начинающих разработчиков

---

## ADR-002: Outbox Pattern для событий Kafka

**Дата**: Январь 2024  
**Статус**: Принято  
**Контекст**: Необходимость гарантированной доставки событий между сервисами при использовании Kafka.

**Решение**: Реализация Outbox Pattern:
1. События записываются в таблицу `outbox_events` в той же транзакции
2. Отдельный сервис `event-relay` читает из outbox и публикует в Kafka
3. Гарантируется хотя бы одна доставка

**Схема**:
```
[Auth Service] → [PostgreSQL outbox_events] → [Event Relay] → [Kafka] → [Другие сервисы]
```

**Последствия**:
- ✅ Гарантированная доставка событий
- ✅ Согласованность данных
- ✅ Отказоустойчивость
- ⚠️ Дополнительная сложность
- ⚠️ Задержка в доставке событий

---

## ADR-003: JWT вместо сессий

**Дата**: Январь 2024  
**Статус**: Принято  
**Контекст**: Требуется stateless аутентификация для горизонтального масштабирования.

**Решение**: Использование JWT (JSON Web Tokens):
- Access tokens (короткоживущие, 15 минут)
- Refresh tokens (долгоживущие, 7 дней)
- Хранение в HTTP-only cookies для безопасности

**Структура токена**:
```json
{
  "sub": "user-id",
  "email": "user@example.com",
  "roles": ["user"],
  "iat": 1700000000,
  "exp": 1700000900,
  "iss": "auth-service"
}
```

**Последствия**:
- ✅ Stateless - легко масштабируется
- ✅ Не требует хранилища сессий
- ✅ Поддержка микросервисной архитектуры
- ⚠️ Невозможность отозвать токены до истечения срока
- ⚠️ Увеличенный размер запросов

---

## ADR-004: TOTP для двухфакторной аутентификации

**Дата**: Январь 2024  
**Статус**: Принято  
**Контекст**: Требуется безопасная 2FA без зависимости от SMS провайдеров.

**Решение**: Time-based One-Time Password (TOTP) по RFC 6238:
- Генерация QR-кодов для Google Authenticator/Authy
- 6-значные коды, обновляемые каждые 30 секунд
- Резервные коды для восстановления

**Реализация**:
- Использование библиотеки `otplib`
- Хранение секретов в зашифрованном виде
- Поддержка нескольких устройств

**Последствия**:
- ✅ Высокая безопасность
- ✅ Offline работа
- ✅ Стандартизированный протокол
- ⚠️ Пользователи должны устанавливать приложение
- ⚠️ Синхронизация времени критична

---

## ADR-005: Минимальные внешние зависимости

**Дата**: Январь 2024  
**Статус**: Принято  
**Контекст**: Уменьшение attack surface и упрощение поддержки.

**Решение**: Использование минимального набора проверенных библиотек:
1. **Express** - HTTP сервер
2. **TypeORM** - ORM для PostgreSQL
3. **jsonwebtoken** - JWT токены
4. **bcryptjs** - хеширование паролей
5. **otplib** - 2FA
6. **Kafkajs** - интеграция с Kafka

**Исключено**:
- NestJS (слишком много магии)
- Passport (избыточность)
- Mongoose (привязка к MongoDB)

**Последствия**:
- ✅ Меньше уязвимостей
- ✅ Быстрее сборка
- ✅ Проще отладка
- ⚠️ Больше собственного кода
- ⚠️ Нет готовых решений для сложных сценариев

---

## ADR-006: PostgreSQL как основное хранилище

**Дата**: Январь 2024  
**Статус**: Принято  
**Контекст**: Требования к транзакционности и согласованности данных.

**Решение**: PostgreSQL 14+ с TypeORM:
- ACID compliance
- Транзакции для outbox pattern
- Миграции через TypeORM
- Репликация для отказоустойчивости

**Схема базы данных**:
```sql
-- Основные таблицы
users (
  id UUID PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  is_active BOOLEAN DEFAULT true,
  is_two_factor_enabled BOOLEAN DEFAULT false,
  two_factor_secret VARCHAR(255),
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);

-- Outbox для событий
outbox_events (
  id UUID PRIMARY KEY,
  type VARCHAR(100) NOT NULL,
  payload JSONB NOT NULL,
  created_at TIMESTAMP,
  processed_at TIMESTAMP,
  error TEXT
);

-- Refresh tokens (для отзыва)
refresh_tokens (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),
  token_hash VARCHAR(255) NOT NULL,
  expires_at TIMESTAMP,
  revoked BOOLEAN DEFAULT false,
  created_at TIMESTAMP
);
```

**Последствия**:
- ✅ Надежность и согласованность
- ✅ Поддержка сложных запросов
- ✅ Зрелая экосистема
- ⚠️ Сложнее горизонтальное масштабирование
- ⚠️ Требуется мониторинг и настройка

---

## ADR-007: CQRS для разделения чтения/записи

**Дата**: Январь 2024  
**Статус**: Отложено  
**Контекст**: Высокая нагрузка на чтение профилей пользователей.

**Решение**: **Отложено** до необходимости:
- Текущая нагрузка не требует разделения
- Усложняет архитектуру
- Можно добавить позже при росте нагрузки

**Альтернатива**: Кэширование через Redis для часто читаемых данных.

---

## ADR-008: Контейнеризация и оркестрация

**Дата**: Январь 2024  
**Статус**: Принято  
**Контекст**: Требуется воспроизводимость и масштабируемость развертывания.

**Решение**: Docker + Kubernetes:
- Многоступенчатый Dockerfile
- Helm charts для развертывания
- Health checks и readiness probes
- Resource limits и requests

**Конфигурация Kubernetes**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: auth-service
  template:
    metadata:
      labels:
        app: auth-service
    spec:
      containers:
      - name: auth-service
        image: auth-service:latest
        ports:
        - containerPort: 3001
        envFrom:
        - secretRef:
            name: auth-service-secrets
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/db
            port: 3001
          initialDelaySeconds: 5
          periodSeconds: 5
```

**Последствия**:
- ✅ Воспроизводимость окружений
- ✅ Автоматическое масштабирование
- ✅ Self-healing
- ⚠️ Сложность настройки
- ⚠️ Требуется инфраструктура

---

## Принципы разработки

### 1. Принцип единой ответственности (SRP)
Каждый класс/модуль отвечает за одну конкретную задачу.

### 2. Dependency Inversion
Зависимости от внешних систем через интерфейсы (ports).

### 3. Fail Fast
Раннее обнаружение ошибок через валидацию и типизацию.

### 4. Graceful Degradation
Сервис должен деградировать корректно при сбоях зависимостей.

### 5. Observability First
Все компоненты должны предоставлять метрики, логи и трассировки.

---

## Эволюция архитектуры

### Фаза 1: MVP (текущая)
- Базовая аутентификация
- 2FA через TOTP
- Outbox pattern
- REST API

### Фаза 2: Масштабирование
- Кэширование через Redis
- Rate limiting распределенный
- Балансировка нагрузки
- Гео-репликация

### Фаза 3: Расширенная безопасность
- WebAuthn для биометрии
- Анализ поведения пользователей
- Advanced threat detection
- Audit logging

---

## Контакты

- **Архитектор**: [Имя архитектора]
- **Техлид**: [Имя техлида]
- **Команда**: Platform Ecosystem Auth Team
- **Обновлено**: Январь 2024
